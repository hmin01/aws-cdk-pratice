import { Construct } from 'constructs';
import { Stack, StackProps, Duration } from 'aws-cdk-lib';
import { aws_iam as iam, aws_ec2 as ec2, aws_lambda as lambda, aws_apigateway as apigateway } from 'aws-cdk-lib';
import { IAMClient, GetRoleCommand } from '@aws-sdk/client-iam';

import * as fs from 'fs';
import * as path from 'path';

const NAMESET_EC2_ROLE    = 'privacyDAM-EC2InstanceRole';
const NAMESET_LAMBDA_ROLE = 'privacyDAM-LambdaRole';
const NAMESET_LAMBDA_NAME = 'privacyDAM-Process';
const NAMESET_APIGATEWAY  = 'privacyDAM-APIs';

const NAMESET = {
  ROLE_LAMBDA: 'privacyDAM-Role-Lambdaaaaaa'
};

export class AwsCdkPracticeStack extends Stack {
  constructor(scope: Construct, id: string, props?: StackProps) {
    super(scope, id, props);

    // const construct = this;

    // Create ec2 instance
    // const instancePublicIP = createEC2Instance(construct);
    
    // Create Role for lambda function
    createRoleForLambda(this);
    



    // // Main
    // (async function() {
    //   // Create ec2 instance
    //   const instancePublicIP = createEC2Instance(construct);
    //   console.log(instancePublicIP);

    //   // Check iam role existing
    //   let roleArn = await checkExistLambdaExcutionRole();
    //   if (roleArn === undefined) {
    //     // Create iam role
    //     roleArn = createLambdaExectionRole(construct);
    //   }

    //   // Load a lambda config data
    //   const file = fs.readFileSync(path.join(__dirname, '../lambda-config.json'));
    //   const config = JSON.parse(file.toString());
    //   // Set OPA HOST and DSN in environment property
    //   // config.environment.OPA = instancePublicIP.

    //   // Create lambda
    //   const fn = createLambdaFunction(construct, roleArn, config);
    //   // Create APIGateway
    //   createApiGateway(construct, fn);
    // })();
  }
}

async function checkExistLambdaExcutionRole(): Promise<string|undefined> {
  // Create iam client (using SDK)
  const client = new IAMClient({region: 'ap-northeast-2'});
  
  // Set the iam input properties and create command
  const command = new GetRoleCommand({ RoleName: NAMESET_LAMBDA_ROLE });
  // Request command
  try {
    const response = await client.send(command);
    return response.Role?.Arn;
  } catch (err) {
    if (err.Code === 'NoSuchEntity') {
      return undefined;
    } else {
      console.error(err);
      process.exit(0);
    }
  }
}

function createLambdaExectionRole(scope: Construct): string {
  // Set the iam role properties
  const props = {
    assumedBy: new iam.ServicePrincipal('lambda.amazonaws.com'),
    description: 'Role to execute lambda generated by privacyDAM',
    managedPolicies: [
      iam.ManagedPolicy.fromAwsManagedPolicyName('service-role/AWSLambdaBasicExecutionRole')
    ],
    path: '/',
    roleName: NAMESET_LAMBDA_ROLE
  };

  // Create iam role
  try {
    const role = new iam.Role(scope, NAMESET_LAMBDA_ROLE, props)
    return role.roleArn;
  } catch (err) {
    console.error(err);
    process.exit(0);
  }
}

function createRoleForLambda(scope: Construct) {
  try {
    const role = iam.ManagedPolicy.fromManagedPolicyName(scope, NAMESET.ROLE_LAMBDA, NAMESET.ROLE_LAMBDA)
    console.log("Role exist");
    console.log(role);
    console.log();
  } catch (err) {
    console.error(err);
    process.exit(0);
  }

  // try {
  //   // Set the iam role properties
  //   const props = {
  //     assumedBy: new iam.ServicePrincipal('lambda.amazonaws.com'),
  //     description: 'Role to execute lambda generated by privacyDAM',
  //     managedPolicies: [
  //       iam.ManagedPolicy.fromAwsManagedPolicyName('service-role/AWSLambdaBasicExecutionRole')
  //     ],
  //     path: '/',
  //     roleName: NAMESET.ROLE_LAMBDA
  //   };

  //   // Create iam role
  //   const role = new iam.Role(scope, NAMESET.ROLE_LAMBDA, props)
  //   return role.roleArn;
  // } catch (err) {
  //   console.error(err);
  //   process.exit(0);
  // }
}

function createLambdaFunction(scope: Construct, roleArn: string, config:any): lambda.Function {
  try {
    // Set role name
    const roleName = NAMESET_LAMBDA_ROLE + "_SET";
    // Set the lambda properties
    const props = {
      code: lambda.Code.fromAsset(path.join(__dirname, '../code/main.zip')),
      description: 'Process API generated by privacyDAM',
      environment: config.environment,
      functionName: 'privacyDAM-process',
      handler: 'main',
      memorySize: config.memory,
      role: iam.Role.fromRoleArn(scope, roleName, roleArn, { mutable: false }),
      runtime: lambda.Runtime.GO_1_X,
      timeout: Duration.seconds(config.timeout)
    }
    // Create lambda
    const fn = new lambda.Function(scope, NAMESET_LAMBDA_NAME, props);
    console.log('[Notice] Create AWS Lambda function');
    return fn;
  } catch (err) {
    console.error(err);
    process.exit(0);
  }
}

function createApiGateway(scope: Construct, fn: lambda.Function) {
  // Set the api gateway properties
  const props = {
    deployOptions: {
      loggingLevel: apigateway.MethodLoggingLevel.INFO
    }
  };
  // Create api gateway
  const api = new apigateway.RestApi(scope, NAMESET_APIGATEWAY, props);

  // Defining APIs
  const mainRouter = api.root.addResource('process');
  const processRouter = mainRouter.addResource('{name}');

  // Create integration and set method
  const integration = new apigateway.LambdaIntegration(fn)
  processRouter.addMethod('GET', integration);
}

function createEC2Instance(scope: Construct): string {
  try {
    // Get the default VPC. This is the network where your instance will be provisioned
    // All activated region in AWS have a default VPC.
    const defaultVpc = ec2.Vpc.fromLookup(scope, 'VPC', { isDefault: true });

    // Set the role properties
    const roleProps = {
      assumedBy: new iam.ServicePrincipal('ec2.amazonaws.com'),
      roleName: NAMESET_EC2_ROLE
    };
    // Lets create a role for the instance
    // You can attach permissions to a role and determine what your instance can or can not do
    const role = new iam.Role(scope, NAMESET_EC2_ROLE, roleProps);

    // Set the security group properties
    const securityGroupProps = {
      vpc: defaultVpc,
      allowAllOutbound: true,
      securityGroupName: 'privacyDAM-BasicSecurityGroup'
    };
    // Lets create a security group for our instance
    // A security group acts as a virtual firewall for your instance to control inbound and outbound traffic.
    const securityGroup = new ec2.SecurityGroup(scope, 'privacyDAM-BasicSecurityGroup', securityGroupProps);
    // Lets use the security group to allow inbound traffic on specific ports
    securityGroup.addIngressRule(ec2.Peer.anyIpv4(), ec2.Port.tcp(22), 'Allow SSH access from internet [using privacyDAM]');
    securityGroup.addIngressRule(ec2.Peer.anyIpv4(), ec2.Port.tcp(3306), 'Allow Mysql(port 3306) access from internet [using privacyDAM]');
    securityGroup.addIngressRule(ec2.Peer.anyIpv4(), ec2.Port.tcp(4000), 'Allow TCP(port 4000) access from internet [using privacyDAM]');
    securityGroup.addIngressRule(ec2.Peer.anyIpv4(), ec2.Port.tcp(4001), 'Allow TCP(port 4001) access from internet [using privacyDAM]');

    // Set the AMI properties
    const amiProps = {
      name: 'privacyDAM-managementServer-v1',
      owners: ['395824177941'],
    };
    // Set the ec2 instance properties
    const instanceProps = {
      vpc: defaultVpc,
      role: role,
      securityGroup: securityGroup,
      instanceName: 'privacyDAM-ManagementServer',
      instanceType: ec2.InstanceType.of(ec2.InstanceClass.T2, ec2.InstanceSize.MICRO),
      machineImage: ec2.MachineImage.lookup(amiProps),
      keyName: 'tov_hmin'
    };
    // Finally elts provision our ec2 instance
    const instance = new ec2.Instance(scope, 'privacyDAM-ManagementServer', instanceProps);
    console.log(instance.instancePublicDnsName.toString());
    return instance.instancePublicIp;
  } catch (err) {
    console.error(err);
    process.exit(0);
  }
}
